Create the Minesweeper Project
Over the course of the next few weeks, you'll use your newly-gained JavaScript knowledge to build a classic computer game: Minesweeper!

In total, there will be 6 parts to this project. Today, you will start on part 1 of the project. You can expect to complete Minesweeper locally, on your own computer.

If you've never played Minesweeper, take a few minutes to become familiar with it: Minesweeper overview.

The following is a quick overview of the game:

The objective is to successfully navigate (or, "clear") a grid of squares without encountering any hidden mines (bombs).
Clicking on a square reveals what is underneath the square.
If a square reveals a mine, the game is over, and you lose.
If a square does not reveal a mine, one of two possible things can happen:
A digit will appear in the square. This digit represents the number of adjacent squares that contain a mine.
Nothing will appear in the square. In this case, the square will clear and become blank. Adjacent squares will then be recursively revealed.
If you want to get a feel for the game by playing it first, try it out here. You can also take look at the diagram outlining "Minesweeper Rules".

Finally, a few notes before getting started:

Minesweeper is traditionally played using a Graphical User Interface (GUI). The GUI allows you to see the grid visually, click on squares, and otherwise read all relevant information in one place. This project, however, will result in a terminal-based game, requiring that you type code into the terminal to play the game.
If you are using Git as you build this project, be sure to create a .gitignore file that includes the node_modules directory.
Let's get started!
Mark the tasks as complete by checking them off
Create Your Project Structure
1.
Open up the terminal on your computer. cd to the directory where you want to store this project and create a new directory called minesweeper.

Next, cd into the newly-created minesweeper directory.
2.
Inside of minesweeper, create a new directory called src.

cd into src and create a file called minesweeper.js. This is where you'll write your code for the majority of the project's duration. We'll refactor and modularize this file as necessary as your code expands.
3.
Finally, this project should support transpilation. Make sure to set up your project to support transpilation before proceeding. The transpilation process will create additional directories that you will need to use. If you need help, refer to our course on Browser Compatibility and Transpilation.
Demo the Project
4.
Before starting, you can always demo a completed version of this project. In the Codecademy terminal to the right, run the following command:

node minesweeper.js
You should see output that reflects what you will build today.
Manually Create an Empty Game Board
5.
At this point, you should be familiar with the objective and rules of the Minesweeper game. If you haven't already played Minesweeper, we encourage you to refer to the resources in the overview of this project.

Remember, Minesweeper is played on a grid of squares. We'll have to manually create that board so that it can be seen in the terminal when a game is in session.

For now, we'll hard code the board to preview what the board will look like. Later, we'll dynamically generate the board.

In src/minesweeper.js, create a constant called blankLine.

Set it equal to

'  |   |  '
The | is the vertical line character (also known as a "pipe"). The blankLine variable represents one row with three columns. The columns are separated with the pipe character. There should be a space on both sides of each pipe and a space where each number or mine could exist.

Again, this is a hard coded solution. Later, we'll dynamically generate the board given some inputs.
Print the Empty Game Board
6.
Let's print what an empty board might look like.

Use console.log() to log the following message:

This is what an empty board would look like:
7.
Next, use console.log() to log the blankLine constant three times.
Run Your File: minesweeper.js
8.
The transpilation process you performed earlier created a lib directory and contains the transpiled version of your minesweeper.js code. From the terminal, transpile your code again and run your code using:

node lib/minesweeper.js
Make sure you are inside the root directory when you run this command. What do you see?
Stuck? Get a hint

Manually Create a Simulated Game Board
9.
Great job! Now you can see what a 3 x 3 game board will look like in the terminal (3 rows, 3 columns, for a total of 9 squares).

Let's hard code what a game board will look like with "guesses" and "mines". Be sure to keep the code you've already written.

First, create a constant called guessLine.

Set it equal to

'1 |   |  '
guessLine represents what the board will look like when a player guesses by "clicking" (selecting) the first square of this row.
10.
On the next line, create a constant called bombLine. (We'll refer to "mines" as "bombs" from now on.)

Set bombLine equal to

'  | B |  '
bombLine represents what the board will look like when a player clicks and reveals a bomb.
Print the Simulated Game Board
11.
Let's print what a board might look like during a game.

First use console.log() to log the following message:

This is what a board with a guess and a bomb on it would look like:
12.
On the next three lines, use console.log() to log guessLine, bombLine, and blankLine, in that order.
Completion and Reflection
13.
Transpile and run your code again in the terminal. You should see the following output:

This is what an empty board would look like:
  |   |
  |   |
  |   |
This is what a board with a guess and a bomb on it would look like:
1 |   |
  | B |
  |   |
Congratulations! You completed the first part of the Minesweeper project.

Reflect on the knowledge you used in this project. As you do so, consider the following questions:

You manually created (and printed) an empty game board and a simulated game board. How might you do this programmatically in the future?
You manually added a guess and a bomb to the simulated game board. How might you add the interactivity required for a learner to guess on the board? How might bombs be added randomly to the board?
We'll expand minesweeper.js throughout the coming weeks to help address the questions above (and more).


*********************

Creating a Game Board
Take a minute to review what you accomplished in the first part of this project. You:

Manually built an empty game board
Printed the empty game board
Manually built a simulated game board
Printed the simulated game board
Unfortunately, both versions of the game board were hard coded. As you continue to build minesweeper.js, we'll want to make sure that game boards can be dynamically generated.

In this part of the project, we'll move closer to that goal. There will still be some hard coding, but you'll also code the foundational parts of the project that will be reused in the future to generate game boards.

Take a minute to review what you accomplished in the first part of this project. You:

Manually built an empty game board
Printed the empty game board
Manually built a simulated game board
Printed the simulated game board
Unfortunately, both versions of the game board were hard coded. As you continue to build minesweeper.js, we'll want to make sure that game boards can be dynamically generated.

In this part of the project, we'll move closer to that goal. There will still be some hard coding, but you'll also code the foundational parts of the project that will be reused in the future to generate game boards.

Let's get started!

**************************************************
Dynamically Generate Game Boards
Welcome to the third installment of the JavaScript Minesweeper project. Take a minute to review what you accomplished in the second part of this project. You:

Used nested arrays to manually create a game board
Wrote a function to neatly log the game board
Accessed the nested arrays to set a guess and a bomb on the game board
In this part of the project, you'll increase the functionality of minesweeper.js by dynamically generating a player board and a bomb board. Whereas previous installments of this project could be completed in 20 lines of code (or less), you should expect to write about 50 lines of code in this third part.

Finally, this third installment will be more difficult than the first two parts. It will require that you read carefully, take risks in writing code, and learn through trial and error. This is a common workflow for software developers. Although the project will be challenging, it will also be highly rewarding: you'll have a more functional file and be one step closer to a polished, final product.

Once again, you'll write in the src/minesweeper.js file.

Feel free to keep the printBoard() function you previously wrote (it'll be refactored in this project), but note that there will be lots of new code. You will be better set up for success if you delete everything and start fresh again. The rest of this project will assume that you are starting anew.

Again, make sure your project is set up for transpilation. Ensure you are in your src directory, transpiling to the lib directory.

Finally, remember that you can also demo a completed version of this project in the Codecademy terminal.
Dynamically Generate a Player Board
2.
Previously, you hard coded the game board and printed its contents manually. In this project, you'll generate the game board dynamically, meaning you won't have to worry about hard coding game boards anymore. The code you write in this project will take care of that problem.

Instead of creating one singular game board, we're going to create two: one board for the player's guesses and another board that will hold the actual bomb locations. Later, you'll write code so that they can communicate with each other.

Start by creating a constant called generatePlayerBoard on line 1 of your file. This will store a function that will generate a blank board of a given size to hold the player's guesses
3.
Set generatePlayerBoard equal to an arrow function that accepts two parameters: numberOfRows and numberOfColumns.
Stuck? Get a hint
4.
Before we continue, let's walk through how this function should behave.

generatePlayerBoard(), when called, will accept two arguments: the number of rows and number of columns.

The function should:

Add an empty space (' ') to each column in every row
Add each row to to a larger game board, thereby constructing the player's board
For example, generatePlayerBoard(2, 3) would result in a game board that looks like the following:

[
  [' ', ' ', ' '],
  [' ', ' ', ' ']
]
This example generated a board with two rows and three columns. Later, you'll write a function that will format the game board to print it.
5.
Inside of the function, start by creating a variable called board. Set it equal to an empty array. This array will represent the overall game board.
6.
In the next few steps, you're going to use nested for loops to iterate through nested arrays to build up the player board. If you're having trouble visualizing how nested for loops iterate through arrays, play the video to the right. It demonstrates exactly how each for loops targets (and iterates) through nested arrays.

After your board declaration, start a for loop that iterates through the number of rows that have been supplied to the function.
7.
Inside of this for loop, create a variable called row. Set it equal to an empty array. This row will represent a single row to be added to the game board.
8.
You'll have to add empty spaces ' ' to each column in the row array you just created. The empty spaces represent squares on the board.

The number of empty spaces that you add to the array must match the number of columns passed to the function.

On the next line, create a for loop that loops through the number of columns specified to the function. (You should still be inside of the first for loop you created.)
9.
Inside of this nested for loop, use the .push() array method to add ' ' to the row array. This is the only line of code that you will write in this nested for loop.

This code will add the correct number of empty spaces (' ', or squares) to each row.
Stuck? Get a hint
10.
Just outside of the closing curly bracket (}) of the inner for loop, use the same method to push the newly-created row into the board array.
Stuck? Get a hint
11.
Finally, just outside of the closing bracket (}) of the outer for loop, return the game board (board).

At the end of the file, try calling your generatePlayerBoard() function with a few different sets of arguments and logging the results to the console. Transiple and run your code to ensure your function is working as intended. Once done, delete these calls.
Stuck? Get a hint

Dynamically Generate a Bomb Board
12.
You just wrote a function that will dynamically generate a player's board no matter what size it is. No more hard coding game boards!

Next, you'll dynamically generate a bomb board. The bomb board is essentially the same as a player board. The only difference is that it is meant to contain only bombs. Later, you will use this board to check players' guesses. For now, let's focus on just dynamically generating the bomb board.

Start by creating a constant called generateBombBoard.
13.
Next, set generateBombBoard equal to an arrow function that takes three parameters: numberOfRows, numberOfColumns, numberOfBombs.
Stuck? Get a hint
14.
Before we continue, let's walk through how this function should behave.

generateBombBoard(), when called, will accept three arguments: a specified number of rows, columns, and bombs.

The function should:

Create the game board of the specified size
Add bombs to random squares on the game board
For example, generateBombBoard(5, 9, 14) would result in a 5 x 9 game board (45 total squares) with 14 bombs placed randomly on the board.
15.
As mentioned before, the creation of the board is nearly identical to what you coded in the previous generatePlayerBoard() function.

Copy all of the code inside of the generatePlayerBoard() function. Paste it all inside of the generateBombBoard() function.
16.
Only one thing needs to change in the code you copied and pasted.

Instead of pushing ' ' to row, replace ' ' with null.
Randomly Place Bombs on the Bomb Board
17.
Perfect! You've added the code that will dynamically generate a bomb board, but you haven't yet added the code that will randomly add bombs to the bomb board, so let's add that to the generateBombBoard() function.

Place your cursor above the following line of code and press "Enter" (or "Return") on your keyboard a few times.

return board;
You'll need some space to fully complete the rest of the function.
18.
Create a variable called numberOfBombsPlaced and set it to 0. This will represent our bomb counter. Once this number reaches the numberOfBombs specified, we can stop adding bombs to the board.
19.
You'll want to continue adding bombs to the board until our counter reaches the specified number of bombs to the function (numberOfBombs).

Create a while loop that meets this condition.
Stuck? Get a hint
20.
To place bombs randomly on the board, we'll have to generate a random location on the board.

Start by creating a variable called randomRowIndex.
21.
Set randomRowIndex equal to a random number between zero and the specified number of rows. Use Math.random() to help you.
Stuck? Get a hint
22.
Briefly skim the documentation for the Math.random() function.

Notice that Math.random() returns any number between 0 and 1 (including 0, but excluding 1). This means that randomRowIndex will almost always be a decimal, which doesn't make sense if we're going to use it to access as an index for an array.

Wrap the code you just wrote with this function. What will it do?
Stuck? Get a hint
23.
Good. Now you can return a random row index that is actually a whole number. On the next line, do almost the exact same thing, but for generating a random column index.
24.
Let's use the random row and column indices to place a bomb on the board!

On the next line, use the board variable and access the space at the generated randomRowIndex and randomColumnIndex. Set it equal to 'B'.
Stuck? Get a hint
25.
On the next line, we'll have to increment the bomb counter. If you don't do this, then the counter will stay set to 0 and the while loop will run forever.

Use the increment operator to increment numberOfBombsPlaced.
Stuck? Get a hint

26.
An important note: The code in your while loop has the potential to place bombs on top of already existing bombs. This will be fixed when you learn about control flow.

Add this note as a comment inside of the while loop.
An Updated printBoard() Function
27.
At this point, you have written about 67% of the code needed to complete this project. You're almost there!

Next, you'll update the printBoard() function you wrote previously.

If you deleted this function, create a constant called printBoard and set it equal to an arrow function that accepts one parameter called board.
Stuck? Get a hint
28.
To print our board, regardless of size, we will join together each element in each row with ' | ' to create a well-formated row and then join together each row with '\n' (the new line character) to print each row on its own line.

Inside your printBoard() function, call the .map() method on the board parameter.
29.
The .map() method requires a callback function as an argument.

Add a callback function in the form of an arrow function. The arrow function should take one parameter called row.
Stuck? Get a hint
30.
In the arrow function, call the .join() method on row and use ' | ' as the separator.

This .map() call will now return an array of formatted rows.
Stuck? Get a hint
31.
In its current state, the callback function will only join the individual elements within one row of the row array (i.e. it'll only join the ' ' elements in one array) . We'll need to join all rows in the array together as well.

Chain a .join() method call onto your .map() method call. Pass '\n' as the separator. This will join together the array of rows with new lines, placing each row on its own line when printed.
Stuck? Get a hint
32.
Great job! This updated printBoard() function will accept a game board as a parameter, iterate through each of its rows, join the individual elements in each row, and then join all rows together. It will return a brand new game board as a single string to be easily printed.

Wrap this line of code with console.log() in order to log the formatted board to the console.
Stuck? Get a hint
Create Both Boards
33.
You have just about all of the code written! Congratulations.

The last thing we'll do is test the functions you've written to make sure they function as necessary.

Create a variable called playerBoard and set it equal to generatePlayerBoard with 3 and 4 as its two parameters.

At this point, you should be writing code below and outside of the printBoard() function.
Stuck? Get a hint
34.
Next, create a variable called bombBoard and set it equal to generateBombBoard() with 3, 4, and 5 as its three parameters.
Stuck? Get a hint
Print Both Boards
35.
Let's print both boards to the console.

On the next line, log a message to the console that says 'Player Board: '.
36.
Next, call the printBoard() function and pass in the playerBoard variable as the argument.
37.
On the next line, log a message to the console that says 'Bomb Board: '.
38.
Next, call the printBoard() function and pass in the bombBoard variable as the argument.
Completion and Reflection
39.
Let's run your code!

In your terminal, transpile your code and run the following command:

node src/minesweeper.js
Your output should resemble the following:

Player Board:
  |   |   |
  |   |   |
  |   |   |
Bomb Board:
 |  | B |
B |  | B |
B | B |  |
A few of things to note:

Remember that the bomb board is randomly generated, so your output may not be an exact replica of the output depicted in the example above. Run your code a couple of more times and notice how the bombs rearrange themselves randomly.
Your bomb board may sometimes have fewer bombs on it than what was specified in the function call. This is due to the missing control flow code mentioned in Step 26.
Your bomb board will not appear as neatly formatted as the player board. This is because you are adding null to its board. This is fine, as this is a board that is intended to only hold information, and not to be printed. We are printing here to demonstrate the utility of the generateBombBoard() function.
40.
Reflect on the knowledge you used in this project. As you do so, consider the following questions:

How might you improve the generateBombBoard() function so that duplicate bombs aren't added to squares that already contain bombs?
We have a function that generates the player board. How will a player actually interact with this board?
Minesweeper will inform you if there is a bomb adjacent to the square you click (if it doesn't contain a bomb itself). How might you implement this functionality into the game?

****************************************************

Minesweeper: Player Interactivity

In this project, you will complete another portion of the Minesweeper project. You'll use your knowledge of control flow and scope to finish your generateBombBoard() function, find the number of bombs around a tile, and determine if a tile was already flipped.

Add Player Interactivity
You've made it to the fourth part of the JavaScript Minesweeper project. Take a minute to review what you accomplished in the third part. You:

Wrote a function to generate a player board
Wrote a function to generate a bomb board and randomly place bombs on the board
Refactored the printBoard() function
In this part of the project, you'll polish minesweeper.js by doing the following:

Refactoring the generateBombBoard() function so that it doesn't add duplicate bombs
Writing a function to retrieve the number of bombs adjacent to the square that has been "clicked" by a player
Building a function that will let a player "click", or "flip", a tile on the board
You should expect to write about 40 new lines of code in this part of the project, bringing the total to around 90 lines of code in minesweeper.js.

Let's get started!

Fix generateBombBoard()
1.
Open your minesweeper.js file. Make sure that you are in your root directory, transpiling from the src directory to the lib directory.

Remember that you can demo a completed version of this project in the Codecademy terminal.
2.
We'll start by fixing the while loop inside of the generateBombBoard() function. Your code should look like this at the moment (or similar to this):

while (numberOfBombsPlaced < numberOfBombs) {
    let randomRowIndex = Math.floor(Math.random() * numberOfRows);
    let randomColumnIndex = Math.floor(Math.random() * numberOfColumns);
    board[randomRowIndex][randomColumnIndex] = 'B';
    numberOfBombsPlaced++;
}
The problem with this code is that it doesn't check to see if there's already a bomb in a tile before placing it in that same tile. This could result in duplicate bombs. Let's fix this.

Write an if statement immediately after the following line of code.

let randomColumnIndex = Math.floor(Math.random() * numberOfColumns);
Stuck? Get a hint
3.
The if statement should check that there is not a 'B' on the board at randomRowIndex and randomColumnIndex.
Stuck? Get a hint
4.
If there isn't a 'B' at that location, then we'll place a bomb there. It turns out, however, that you've already written the code that will do this.

Copy the following lines of code and paste them inside of the if statement's body:

board[randomRowIndex][randomColumnIndex] = 'B';
numberOfBombsPlaced++;
Add getNumberOfNeighborBombs()
5.
Next, you'll build one of the main pieces of Minesweeper functionality: displaying the number of bombs adjacent to the flipped tile.

Here's a brief overview of how this function will work:

The function will determine the size of the game board
The function will use the location of the flipped tile
Using an array index offset system (more on this later), the function will check all adjacent tiles for bombs
If a bomb exists at an adjacent tile, you'll record it by incrementing a bomb counter
The number of bombs adjacent to the flipped tile will be returned by the function
This will be a challenging function to write, but we'll guide you through it. At the same time, don't be afraid to take risks, make mistakes, and learn by doing. Let's start.

Create a constant called getNumberOfNeighborBombs. Place it after the closing curly brace (}) of the generateBombBoard() function.
6.
Set getNumberOfNeighborBombs equal to an arrow function. The arrow function should accept three parameters: bombBoard, rowIndex, columnIndex. This will calculate the number of bombs next to the square at the given rowIndex and columnIndex on the provided bombBoard.
Stuck? Get a hint
7.
A flipped tile can have 8 possible neighbors, at most, no matter the size of a board:

 a | b | c
 d | + | e
 f | g | h
In the example above, the + represents a flipped tile. The letters surrounding it represent adjacent neighbors.

We'll need a way to represent tiles that are adjacent to a flipped tile.

The board that we have created is a two-dimensional array â€” an array of arrays. Each array is a row on the board and each index of these arrays constitute the columns.

Each element in the example above is at most 1 row and 1 column away from the flipped tile, +.

For example, f is 1 row after and 1 column before the flipped tile. We have to add 1 to the row and subtract 1 from the column. This would be [1,- 1]

There are eight possible combinations of [1]s and [-1]s that would represent each adjacent neighbor.

If you're having trouble visualizing this system, take a look at the diagram to the right. It demonstrates a flipped tile (denoted with an X). All other tiles are represented with their corresponding offsets.

We'll store the pairs of [rowOffset, columnOffset] for adjacent neighbors in an array. Inside of your function, create a constant called neighborOffsets and start by setting it equal to an empty array.
Stuck? Get a hint
8.
Next, add 8 empty arrays to the neighborOffsets array. We'll use these nested arrays to represent the 8 possible offset combintations of neighboring tiles.
Stuck? Get a hint
9.
Fill in each nested array with the row and column offsets of the surrounding tiles. The order in which you add them doesn't matter.
Stuck? Get a hint

10.
Great! neighborOffsets will help us check adjacent tiles for bombs later.

As we check adjacent tiles, we'll need to make sure we are checking valid tiles. For example, what if a flipped tile is on an edge of the game board? In that case, it may be missing some adjacent tiles, like so:

 a | b | c
 d | + | e
In the example above, the flipped tile + is at the bottom edge of a game board. That means it is missing three adjacent neighbors.

We can start checking these cases by first retrieving the dimensions of the game board.

On the next line, create a constant called numberOfRows. Set it equal to the length of the bombBoard that is passed into the function as a parameter.
Stuck? Get a hint


11.
We'll also want the total number of columns.

On the next line, create a constant called numberOfColumns. Set it equal to the length of the first element of bombBoard. (The first element is a row, and the number of entries in a row represents the total number of columns).

See if you can complete this without looking at the hint.
Stuck? Get a hint
12.
On the next line, create a variable called numberOfBombs. Set it equal to 0. This variable will be used to store the number of bombs adjacent to the flipped tile.
13.
Now comes the challenging part. We'll have to build the following interactivity:

Grab the row and column indices of the tile that a user specifies (say they input 0, 2, we'll have to use that to check for bombs around the tile in the first row and third column)
Check all possible neighboring tiles around the indicated tile
If a neighboring tile has a bomb, increment the bomb counter
Start by calling the .forEach() method on the neighborOffsets array.
Stuck? Get a hint
14.
.forEach() requires a callback method. Pass one in as an arrow function. The arrow function should take one parameter called offset.
Stuck? Get a hint
15.
At this point, we're set up to iterate through each array in neighborOffsets. We'll use these row and column offsets to check the neighbors around a flipped tile.

Inside of the callback function, create a constant called neighborRowIndex.
Stuck? Get a hint
16.
Recall that getNumberOfNeighborBombs() accepts a rowIndex and a columnIndex. These two parameters represent the row and column indices of a tile that is to be flipped. We'll have to use these parameters to check for neighboring tiles.

Let's store the index of a neighboring tile (on a row). Set neighborRowIndex equal to the sum of rowIndex and the first element of offset.

(Recall that offset represents a nested array in neighborOffsets.)
Stuck? Get a hint
17.
We'll need to do the same thing for columns. On the next line, create a constant called neighborColumnIndex. Set it equal to the sum of columnIndex and the second element in offset.
Stuck? Get a hint

18.
Next, you'll need to check if the row and column indices for neighboring tiles are valid (for example, we don't want to check tiles that are "off the grid" and don't exist).

Start by adding an if statement on the next line.
19.
The expression that the if statement needs to check that all of the following conditions are met:

neighborRowIndex is greater than or equal to 0
neighborRowIndex does not exceed the total number of rows
neighborColumnIndex is greater than or equal to 0
neighborColumnIndex does not exceed the total number of columns
Stuck? Get a hint

20.
Great job! That condition will make sure we are checking legal/valid neighboring tiles.

Next, we'll want to check if the tile at those indices (on the bombBoard) already contains a bomb ('B').

Nest another if statement that checks for this condition. Remember, you're checking to see if bombBoard has a 'B' at the neighboring row and column indices.
Stuck? Get a hint
21.
If both of these conditions are met, then we'll want to increment numberOfBombs. This should be the only line of code inside of the nested if statement.
22.
At this point, the section of code for neighborOffsets.forEach() is complete.

Recall that the purpose of this function is to return the number of bombs in an adjacent neighbor.

Right after the close of the .forEach() method (});), but before just before the close of the function ();), return numberOfBombs.
Stuck? Get a hint
Add flipTile()
23.
Congrats on completing a challenging function!

Next, you'll need to write a function that will allow the user to flip a tile.

On the next line, create a constant called flipTile. Set it equal to an arrow function that acccepts four parameters: playerBoard, bombBoard, rowIndex, columnIndex.
24.
The goal of flipTile() is to allow the player to flip a tile and to update that tile accordingly. The function should explicitly check for two things:

If the specified tile has already been flipped
If the specified tile has a bomb in it
Otherwise, that tile should be updated with the number of neighboring bombs. Let's begin.

Start by creating an if statement. The if statement should check to see if the specified tile in playerBoard (using rowIndex and columnIndex) is not empty. "Empty" means ' '.
Stuck? Get a hint

25.
Inside, inform the user with a message that says This tile has already been flipped!.

On the next line, return.
26.
Let's continue to chain off of this if statement. Add an else if statement. It should check if there is a bomb 'B' at the specified tile on the bombBoard. (Make sure to read that last sentence carefully.)
27.
If there is a bomb at that row index and column index on the bomb board, we should place a bomb at those same row and column indices on the playerBoard.

Inside of the else if, set the tile at the specified location to 'B'. This line of code places a bomb on the player board by checking the bomb board!
28.
Let's finish this chained if / else if statement. Add an else part to the statement.

At this point, the code will have checked to see if:

The tile is not empty (already been flipped)
There is a bomb at that tile
If none of these cases are true, we should let the user flip the tile and then display the number of neighboring bombs on that same tile. (You already wrote a function to grab the number of neighboring bombs!)

Inside of the else portion, access the specified tile on playerBoard. Set it equal to calling getNumberOfNeighborBombs with bombBoard, rowIndex, and columnIndex as arguments. See if you can do this without looking at the hint.
Stuck? Get a hint
Use flipTile()
29.
At this point, you're just about done with this project! Let's write a couple more lines of code to test out your functions!

On the very last line of minesweeper.js, call the flipTile() function. Pass in playerBoard, bombBoard, 0, and 0 as parameters.

(This will flip the tile at location [0,0] on the player board, and also check the bomb board for bombs at the location).
30.
On the next line, log a message that says 'Updated Player Board:. This will help you read the output clearly.
31.
We'll need to print out the player board to see flipTile() in action.

On the next line, call the printBoard() function and pass in playerBoard as an argument.
Completion and Reflection
32.
Run your file in the terminal! What do you see?

Here's some example output when flipping the tile at location [0, 0]:

Player Board:
  |   |
  |   |
  |   |
Bomb Board:
 | B |
B |  |
B |  |
Updated Player Board:
2 |   |
  |   |
  |   |
Your output will likely look different (i.e., you weren't instructed to add messages to distinguish between the player board, the bomb board, and an updated player board, but feel free to include this in your code).

Keep running your file in the terminal repeatedly. Notice how the bomb board resets randomly and how the player board updates accordingly.

Alternatively, try passing in different locations to flipTile() to see how the player board changes. (You'll have to run your file again to see the changes).

Congratulations! You've completed the fourth part of the Minesweeper project.
33.
Reflect on the knowledge you used in this project. As you do so, consider the following questions:

How might we better organize minesweeper.js?
To play Minesweeper, you have to manually call flipTile() in the file repeatedly. How might we abstract this functionality such that a player could do this directly from the terminal?
We'll expand minesweeper.js throughout the coming weeks to help address the questions above (and more).
